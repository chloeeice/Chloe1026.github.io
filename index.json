[{"categories":null,"content":"1. Binary Tree Traversal - Preorder, Inorder and Postorder ","date":"2022-07-28","objectID":"/binary_tree_traversal/:0:0","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"1. Recursively recursively前中后序遍历代码几乎一样，只是顺序不同。 ","date":"2022-07-28","objectID":"/binary_tree_traversal/:1:0","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"LC 144: Binary Tree Preorder Traversal class Solution { public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); dfs(root, res); return res; } private void dfs(TreeNode root, List\u003cInteger\u003e list) { if (root == null) { return; } list.add(root.val); dfs(root.left, list); dfs(root.right, list); } } ","date":"2022-07-28","objectID":"/binary_tree_traversal/:1:1","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"LC 94: Binary Tree Inorder Traversal class Solution { public List\u003cInteger\u003e inorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); dfs(root, res); return res; } private void dfs(TreeNode root, List\u003cInteger\u003e list) { if (root == null) { return; } dfs(root.left, list); list.add(root.val); dfs(root.right, list); } } ","date":"2022-07-28","objectID":"/binary_tree_traversal/:1:2","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"LC 145: Binary Tree Postorder Traversal class Solution { public List\u003cInteger\u003e postorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); dfs(root, res); return res; } private void dfs(TreeNode root, List\u003cInteger\u003e list) { if (root == null) { return; } dfs(root.left, list); dfs(root.right, list); list.add(root.val); } } ","date":"2022-07-28","objectID":"/binary_tree_traversal/:1:3","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"2. Iteratively ","date":"2022-07-28","objectID":"/binary_tree_traversal/:2:0","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"1. preorder traversal 借助栈。思路与后序遍历(借助栈)基本相同，只有左右子树入栈顺序不同。 思路： step1：root入栈； step2：top元素出栈； step3：将top.val放入链表，同时，top的右子树先入栈，左子树后入栈； step4：重复step2，当栈为空时停止循环。 class Solution { public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); if (root == null) { return res; } Stack\u003cTreeNode\u003e stack = new Stack\u003c\u003e(); stack.push(root); while (!stack.isEmpty()) { TreeNode curNode = stack.pop(); res.add(curNode.val); /**入栈：先右子树，后做子树*/ if (curNode.right != null) { stack.push(curNode.right); } if (curNode.left != null) { stack.push(curNode.left); } } return res; } } ","date":"2022-07-28","objectID":"/binary_tree_traversal/:2:1","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"2. inorder traversal 思路：pointer指向root，并且入栈，一路向左下，逐个入栈，直至到达null（即到达leaf），然后开始出栈 class Solution { public List\u003cInteger\u003e inorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); if (res == null) { return res; } Stack\u003cTreeNode\u003e stack = new Stack\u003c\u003e(); TreeNode curNode = root; //当stack和curNode均为空时，既无node需要入栈，也无node需要出栈， 则退出循环。 while (!stack.isEmpty() || curNode != null) { while (curNode != null) { stack.push(curNode); curNode = curNode.left; } curNode = stack.pop(); res.add(curNode.val); curNode = curNode.right; } return res; } } ","date":"2022-07-28","objectID":"/binary_tree_traversal/:2:2","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"3. postorder traversal 思路： step1：root入栈； step2：top元素出栈； step3：将top.val放入链表，同时，top的左子树先入栈，右子树后入栈； step4：重复step2，当栈为空时停止循环。 class Solution { public List\u003cInteger\u003e postorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); if (root == null) { return res; } Stack\u003cTreeNode\u003e stack = new Stack\u003c\u003e(); stack.push(root); while (!stack.isEmpty()) { TreeNode curNode = stack.pop(); res.add(0, curNode.val); /**入栈：先左子树，后右子树。*/ if (curNode.left != null) { stack.push(curNode.left); } if (curNode.right != null) { stack.push(curNode.right); } } return res; } } 2. Binary Tree Traversal - Level Order ","date":"2022-07-28","objectID":"/binary_tree_traversal/:2:3","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"LC 102: Binary Tree Level Order Traversal 思路：借助queue 重点：队列中的元素出队列时，其左右子树（若非空）需要入队列 关于数据结构：链表可以实现队列 class Solution { public List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e(); if (root == null) { return res; } Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); queue.add(root); while (!queue.isEmpty()) { int qLen = queue.size(); List\u003cInteger\u003e level = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c qLen; i +=1) { TreeNode curNode = queue.poll(); level.add(curNode.val); if (curNode.left != null) { queue.add(curNode.left); } if (curNode.right != null) { queue.add(curNode.right); } } res.add(level); } return res; } } ","date":"2022-07-28","objectID":"/binary_tree_traversal/:3:0","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"LC 103：Binary Tree Zigzag Level Order Traversal 思路：跟LC102非常相似，就是在102的基础上加了一个参数count，当count为偶数时，从左往右；当count为奇数时，从右往左。 class Solution { public List\u003cList\u003cInteger\u003e\u003e zigzagLevelOrder(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e(); if (root == null) { return res; } Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); queue.add(root); int count = 0; while (!queue.isEmpty()) { int qLen = queue.size(); List\u003cInteger\u003e level = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c qLen; i += 1) { TreeNode curNode = queue.poll(); /**当层数为偶数时，一直addlast；当层数为奇数时，一直addfirst。*/ if (count%2 == 0) { level.add(curNode.val); } else { level.add(0, curNode.val); } if (curNode.left != null) { queue.add(curNode.left); } if (curNode.right != null) { queue.add(curNode.right); } } res.add(level); count += 1; } return res; } } ","date":"2022-07-28","objectID":"/binary_tree_traversal/:4:0","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"LC 107. Binary Tree Level Order Traversal II 思路：在LC 102的基础上，只有一行代码有所改动。 class Solution { public List\u003cList\u003cInteger\u003e\u003e levelOrderBottom(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e(); if (root == null) { return res; } Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); queue.add(root); while (!queue.isEmpty()) { int qLen = queue.size(); List\u003cInteger\u003e level = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c qLen; i +=1) { TreeNode curNode = queue.poll(); level.add(curNode.val); if (curNode.left != null) { queue.add(curNode.left); } if (curNode.right != null) { queue.add(curNode.right); } } /**lc102是addlast，这道题这里改成addfirst即可。*/ res.add(0, level); } return res; } } ","date":"2022-07-28","objectID":"/binary_tree_traversal/:5:0","tags":null,"title":"Binary_Tree_Traversal","uri":"/binary_tree_traversal/"},{"categories":null,"content":"second post:test ","date":"2022-07-22","objectID":"/secondpost/:0:0","tags":null,"title":"Secondpost","uri":"/secondpost/"},{"categories":null,"content":"first post ","date":"2022-07-22","objectID":"/first_post/:0:0","tags":null,"title":"First_post","uri":"/first_post/"}]